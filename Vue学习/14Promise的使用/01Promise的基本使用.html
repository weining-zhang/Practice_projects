<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
<script>
  //1、使用setTimeout
  // setTimeout(()=> {
  //   console.log('hello world!');
  // }, 1000)

  //2、使用Promise，参数要求传入一个函数，这个函数要求传入两个参数resolve和reject，resolve和reject本身也是函数.
  //  网络请求都在Promise里面，处理网络请求的代码都在Promise后的then里面
  // new Promise((resolve, reject) => {

  //   // 第一次网络请求的代码
  //   setTimeout(() => {
  //     resolve()
  //   }, 1000);
  // }).then(() => {

  //   // 第一次拿到结果的处理代码
  //   console.log('this is the first time.');
  //   console.log('this is the first time.');

  //   return new Promise((resolve, reject) => {

  //     //第二次网络请求的代码
  //     setTimeout(() => {
  //       resolve()
  //     }, 1000);
  //   })
  // }).then(() => {

  //   //第二次拿到结果的处理代码
  //   console.log('this is the second time.');
  //   console.log('this is the second time.');
    
  //   return new Promise((resolve, reject) => {

  //     //第三次网路请求的代码
  //     setTimeout(() => {
  //       resolve()
  //     }, 1000);
  //   })
  // }).then(() => {

  //   //第三次处理的代码
  //   console.log('this is the third time');
  //   console.log('this is the third time');
  // })

  //什么时候使用Promise？
  //一般情况下是有异步操作时，使用Promise对这个异步操作进行封装
  // new -> 构造函数(1.保存了一些状态信息 2.执行传入的函数)
  //构造函数在执行传入的回调函数时，会传入两个参数，resolve和reject，它们本身又是函数
  new Promise((resolve, reject) => {
    setTimeout(() => {
      //resolve对应then，reject对应catch

      // 成功的时候调用resolve
      // resolve('hello world')

      //失败的时候调用reject
      reject('error message')
    }, 1000);
  }).then(data => {
    console.log(data);
    console.log(data);
    console.log(data);
  }).catch(err => {
    console.log(err);
  })
</script>
</body>
</html>